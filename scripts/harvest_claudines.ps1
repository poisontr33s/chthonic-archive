# Harvest “outside” Claudine scripts into this repo for inspection/upcycling.
#
# This is explicit, opt-in tooling (no background auto-activation).
# It collects candidate files and (optionally) copies them into
# `dumpster-dive/intake/claudine-harvest/` with a manifest.

[CmdletBinding()]
param(
    # Roots to search. Keep this narrow by default to avoid slow scans.
    [string[]]$SearchRoots = @(
        "$env:USERPROFILE\Documents\PowerShell",
        "$env:USERPROFILE\Documents\WindowsPowerShell"
    ),

    # Filename patterns considered “Claudine variants”.
    [string[]]$NamePatterns = @(
        "claudine.ps1",
        "*claudine*.ps1"
    ),

    # Optional: search by content fingerprints (regex). If provided, files are included when ANY pattern matches.
    # Use this to find “fun/drunk scripts” even when filenames don’t mention claudine.
    [string[]]$ContentPatterns,

    # Exclude directories by path fragment (regex). Helps avoid crawling huge trees.
    [string[]]$ExcludeDirPatterns = @(
        '(?i)\\\.git(\\|$)',
        '(?i)\\node_modules(\\|$)',
        '(?i)\\target(\\|$)',
        '(?i)\\build(\\|$)',
        '(?i)\\AppData(\\|$)',
        '(?i)\\\.venv(\\|$)',
        '(?i)\\venv(\\|$)'
    ),

    # Safety cap for broad scans (approx). 0 = no cap.
    [int]$MaxCandidates = 5000,

    # Roots to exclude from harvesting (defaults to this repo).
    [string[]]$ExcludeRoots,

    # Include PowerShell profile scripts even if they don’t match patterns.
    [switch]$IncludeProfiles,

    # Follow referenced .ps1 paths found inside harvested files (opt-in).
    [switch]$FollowReferences,

    # Siphon (extract) only the relevant blocks (alias + auto-activation) into snippet files.
    # This avoids wholesale copying of “drunk scripts” while still ingesting the payload.
    [switch]$Siphon,

    # Copy results into the repo intake folder.
    [switch]$Copy,

    # Overwrite existing harvested files if names collide.
    [switch]$Force
)

$ErrorActionPreference = 'Stop'

function Test-LikelyPackageShim {
    param(
        [Parameter(Mandatory = $true)][string]$Path,
        [Parameter(Mandatory = $true)][string]$Text
    )

    if (-not $Text) { return $false }

    # Heuristics for generated PowerShell shims/wrappers (npm/pnpm/yarn).
    # Keep this conservative: we only use it to skip noise when there is no high-signal claudine content.
    $patterns = @(
        '(?im)^\s*\$basedir\s*=\s*Split-Path\s+\$MyInvocation\.MyCommand\.Definition\s+-Parent\s*$',
        '(?i)node_modules\\\.bin',
        '(?i)generated by\s+(npm|pnpm|yarn)',
        '(?i)\bpnpm\b.*\bshim\b',
        '(?i)\bnode\.exe\b'
    )

    foreach ($pat in $patterns) {
        if ($Text -match $pat) {
            return $true
        }
    }

    # Path hint (rare with current defaults, but helps if SearchRoots is broadened).
    if ($Path -match '(?i)\\node_modules\\\.bin\\') {
        return $true
    }

    return $false
}

function Resolve-ProfilePaths {
    $paths = @()

    # Try to get the standard 4 profile paths.
    $profileCandidates = @(
        $PROFILE,
        $PROFILE.CurrentUserCurrentHost,
        $PROFILE.CurrentUserAllHosts,
        $PROFILE.AllUsersCurrentHost,
        $PROFILE.AllUsersAllHosts
    ) | Where-Object { $_ -and $_.Trim() } | Select-Object -Unique

    foreach ($p in $profileCandidates) {
        try {
            $full = [System.IO.Path]::GetFullPath($p)
            $paths += $full
        }
        catch {
            # ignore
        }
    }

    return $paths | Select-Object -Unique
}

$repoRoot = Split-Path -Parent $PSScriptRoot
$repoRootFull = [System.IO.Path]::GetFullPath($repoRoot)
$exclude = @()
if ($ExcludeRoots -and $ExcludeRoots.Count -gt 0) {
    foreach ($e in $ExcludeRoots) {
        if ($e -and (Test-Path $e)) {
            try { $exclude += [System.IO.Path]::GetFullPath($e) } catch { }
        }
    }
}
else {
    $exclude = @($repoRootFull)
}

$intakeDir = Join-Path $repoRoot 'dumpster-dive\intake\claudine-harvest'
$null = New-Item -ItemType Directory -Force -Path $intakeDir

$snippetsDir = Join-Path $intakeDir 'snippets'
if ($Siphon) {
    $null = New-Item -ItemType Directory -Force -Path $snippetsDir
}

$results = New-Object System.Collections.Generic.List[object]

function Should-ExcludePath([string]$fullPath) {
    if (-not $fullPath) { return $false }

    # Hard exclusions (substring): avoid crawling vendor/build trees regardless of regex config.
    $hard = @(
        '\\.git\\',
        '\\node_modules\\',
        '\\node_modules\\.bin\\',
        '\\target\\',
        '\\build\\',
        '\\AppData\\',
        '\\\.venv\\',
        '\\venv\\'
    )
    foreach ($h in $hard) {
        if ($fullPath.IndexOf($h, [System.StringComparison]::OrdinalIgnoreCase) -ge 0) {
            return $true
        }
    }

    foreach ($pat in $ExcludeDirPatterns) {
        if ($pat -and ($fullPath -match $pat)) {
            return $true
        }
    }
    return $false
}

# 1) Pattern-based search
foreach ($root in $SearchRoots) {
    if (-not (Test-Path $root)) {
        continue
    }

    foreach ($pattern in $NamePatterns) {
        Get-ChildItem -Path $root -Filter $pattern -File -Recurse -ErrorAction SilentlyContinue |
            Where-Object { -not (Should-ExcludePath $_.FullName) } |
            ForEach-Object {
                $results.Add([pscustomobject]@{
                    Kind = 'file'
                    Path = $_.FullName
                })
            }
    }
}

# 1b) Optional: content-fingerprint scan for *.ps1
if ($ContentPatterns -and $ContentPatterns.Count -gt 0) {
    foreach ($root in $SearchRoots) {
        if (-not (Test-Path $root)) {
            continue
        }

        $pipeline = Get-ChildItem -Path $root -Filter "*.ps1" -File -Recurse -ErrorAction SilentlyContinue |
            Where-Object { -not (Should-ExcludePath $_.FullName) }

        if ($MaxCandidates -gt 0) {
            $pipeline = $pipeline | Select-Object -First $MaxCandidates
        }

        foreach ($item in $pipeline) {
            $p = $item.FullName
            try {
                if ($item.Length -gt 1048576) { continue }
                $t = [System.IO.File]::ReadAllText($p)
                foreach ($pat in $ContentPatterns) {
                    if ($pat -and ($t -match $pat)) {
                        $results.Add([pscustomobject]@{ Kind = 'content'; Path = $p })
                        break
                    }
                }
            }
            catch {
                continue
            }
        }
    }
}

# 2) Optional: include profile scripts explicitly
if ($IncludeProfiles) {
    foreach ($profilePath in (Resolve-ProfilePaths)) {
        if (Test-Path $profilePath) {
            $results.Add([pscustomobject]@{
                Kind = 'profile'
                Path = $profilePath
            })
        }
    }
}

# De-dupe by path
$results = $results |
    Group-Object Path |
    ForEach-Object { $_.Group | Select-Object -First 1 }

# Exclude anything inside excluded roots (default: this repo)
$results = $results | Where-Object {
    $p = $_.Path
    if (-not $p) { return $false }
    try {
        $full = [System.IO.Path]::GetFullPath($p)
    }
    catch {
        return $true
    }

    foreach ($e in $exclude) {
        if ($e -and $full.StartsWith($e, [System.StringComparison]::OrdinalIgnoreCase)) {
            return $false
        }
    }
    return $true
}

# Build metadata
$manifest = @()
$skippedLikelyShims = 0
foreach ($r in $results) {
    $p = $r.Path
    try {
        $item = Get-Item -LiteralPath $p -ErrorAction Stop
        $hash = (Get-FileHash -Algorithm SHA256 -LiteralPath $p).Hash

        $text = $null
        $signals = @{}
        if ($item.Length -le 1048576) {
            try {
                $text = [System.IO.File]::ReadAllText($p)
            }
            catch {
                $text = $null
            }
        }

        if ($null -ne $text) {
            $signals.contains_set_alias_claudine = [bool]($text -match '(?i)\bSet-Alias\b[^\r\n]*\bclaudine\b')
            $signals.contains_claudine_auto_activation = [bool]($text -match '(?i)CLAUDINE\s+AUTO-ACTIVATION')
            $signals.contains_psychonoir_path = [bool]($text -match '(?i)PsychoNoir-Kontrapunkt')
            $signals.contains_claudine_activated_var = [bool]($text -match '(?i)\$env:CLAUDINE_ACTIVATED')
            $signals.contains_env_path_mutation = [bool]($text -match '(?im)^\s*\$env:(Path|PATH)\s*=')

            $isHighSignal = (
                $signals.contains_set_alias_claudine -or
                $signals.contains_claudine_auto_activation -or
                $signals.contains_psychonoir_path -or
                $signals.contains_claudine_activated_var -or
                $signals.contains_env_path_mutation
            )

            $signals.likely_pkg_shim = (Test-LikelyPackageShim -Path $p -Text $text)
            if ($signals.likely_pkg_shim -and (-not $isHighSignal)) {
                $skippedLikelyShims++
                continue
            }

            # Capture explicit Windows absolute .ps1 references for optional follow-up ingest.
            $refs = @()
            foreach ($m in [regex]::Matches($text, '(?i)[A-Z]:\\[^\r\n\s\"]+?\.ps1')) {
                $refs += $m.Value
            }
            $signals.referenced_ps1 = @($refs | Select-Object -Unique)

            if ($Siphon) {
                $snips = @()

                foreach ($m2 in [regex]::Matches($text, '(?im)^\s*Set-Alias\b[^\r\n]*\bclaudine\b.*$')) {
                    $snips += $m2.Value
                }

                # Try to capture the common auto-activation block.
                $auto = $null
                $autoMatch = [regex]::Match(
                    $text,
                    '(?is)(^.*CLAUDINE\s+AUTO-ACTIVATION.*?$.*?^\s*#\s*═+\s*END.*?$)'
                )
                if ($autoMatch.Success) {
                    $auto = $autoMatch.Groups[1].Value
                }
                elseif ($text -match '(?is)CLAUDINE\s+AUTO-ACTIVATION') {
                    # Fallback: from marker to end.
                    $auto = ([regex]::Match($text, '(?is)(CLAUDINE\s+AUTO-ACTIVATION.*)$')).Groups[1].Value
                }

                if ($auto) {
                    $snips += $auto
                }

                # If the file uses section headers (common in claudineENV.ps1), siphon whole sections first.
                # Otherwise fall back to line-level payload extraction.
                $pathSection = [regex]::Match($text, '(?is)(#\s*PATH\s+ACTIVATION\b.*?)(?=\n#\s*OUTPUT\b|\z)')
                $envSection  = [regex]::Match($text, '(?is)(#\s*ENVIRONMENT\s+VARIABLES\b.*?)(?=\n#\s*OUTPUT\b|\z)')

                if ($pathSection.Success -or $envSection.Success) {
                    if ($pathSection.Success) {
                        $snips += $pathSection.Groups[1].Value.TrimEnd()
                    }

                    # Only add the ENV section if it wasn't already included by the PATH section capture.
                    # (claudineENV.ps1 nests ENV below PATH, so capturing both can duplicate content.)
                    if ($envSection.Success -and -not $pathSection.Success) {
                        $snips += $envSection.Groups[1].Value.TrimEnd()
                    }
                } else {
                    # PATH/env payload siphon: extract the concrete mutation lines.
                    # This targets “crude mode” violations (PATH rewriting + env var stomping).
                    foreach ($m3 in [regex]::Matches($text, '(?im)^\s*\$env:(Path|PATH)\s*=.*$')) {
                        $snips += $m3.Value
                    }
                    foreach ($m4 in [regex]::Matches($text, '(?im)^\s*\$env:(CLAUDINE_ACTIVATED|CLAUDINE_VERSION|GOROOT|GOPATH|RIDK_PREFIX)\s*=.*$')) {
                        $snips += $m4.Value
                    }
                }

                # Keep output deterministic and compact.
                $snips = @($snips | Where-Object { $_ -and $_.Trim() } | Select-Object -Unique)

                if ($snips.Count -gt 0) {
                    $snippetPath = Join-Path $snippetsDir ("{0}__siphon.ps1" -f $hash.Substring(0, 16))
                    ($snips -join "`r`n`r`n") | Set-Content -Encoding UTF8 -LiteralPath $snippetPath
                }
            }
        }

        $manifest += [pscustomobject]@{
            kind = $r.Kind
            path = $p
            length = $item.Length
            lastWriteTimeUtc = $item.LastWriteTimeUtc.ToString('o')
            sha256 = $hash
            signals = $signals
        }
    }
    catch {
        $manifest += [pscustomobject]@{
            kind = $r.Kind
            path = $p
            error = $_.Exception.Message
        }
    }
}

if ($FollowReferences) {
    $refPaths = @()
    foreach ($m in $manifest) {
        if ($m.error) { continue }
        if ($null -eq $m.signals) { continue }
        if ($null -eq $m.signals.referenced_ps1) { continue }
        foreach ($rp in $m.signals.referenced_ps1) {
            if ($rp -and (Test-Path $rp)) {
                $refPaths += $rp
            }
        }
    }

    $refPaths = $refPaths | Select-Object -Unique
    foreach ($rp in $refPaths) {
        $results += [pscustomobject]@{ Kind = 'reference'; Path = $rp }
    }

    # Re-run de-dupe after adding references.
    $results = $results |
        Group-Object Path |
        ForEach-Object { $_.Group | Select-Object -First 1 }
}

# Write manifest (always)
$manifestPath = Join-Path $intakeDir 'manifest.json'
$manifest | ConvertTo-Json -Depth 5 | Set-Content -Encoding UTF8 -LiteralPath $manifestPath

# Print a compact table
$manifest |
    Where-Object { -not $_.error } |
    Sort-Object kind, path |
    Select-Object kind, sha256, length, @{n='alias';e={$_.signals.contains_set_alias_claudine}}, @{n='auto';e={$_.signals.contains_claudine_auto_activation}}, path |
    Format-Table -Auto

Write-Host "\nManifest written: $manifestPath" -ForegroundColor DarkGray
if ($skippedLikelyShims -gt 0) {
    Write-Host "Skipped likely package-manager shims: $skippedLikelyShims" -ForegroundColor DarkGray
}

if (-not $Copy) {
    if ($Siphon) {
        Write-Host "Siphon snippets written (by sha prefix) in: $snippetsDir" -ForegroundColor DarkGray
    }
    Write-Host "(No -Copy) File staging skipped. Re-run with -Copy to stage full files into the repo intake folder." -ForegroundColor DarkGray
    exit 0
}

# Copy files into intake folder using a stable name based on sha + leaf
foreach ($m in $manifest) {
    if ($m.error) { continue }

    $src = $m.path
    $leaf = Split-Path -Leaf $src
    $safeLeaf = $leaf -replace '[^A-Za-z0-9._-]', '_'
    $dstName = "{0}__{1}" -f $m.sha256.Substring(0, 16), $safeLeaf
    $dst = Join-Path $intakeDir $dstName

    if ((Test-Path $dst) -and (-not $Force)) {
        continue
    }

    Copy-Item -LiteralPath $src -Destination $dst -Force:$Force
}

Write-Host "Staged copies in: $intakeDir" -ForegroundColor Green
